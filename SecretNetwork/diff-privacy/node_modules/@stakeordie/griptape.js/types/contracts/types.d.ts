import { ExecuteResult, TxsResponse } from 'secretjs';
import { Coin } from 'secretjs/types/types.js';
export interface Context {
    address?: string;
    key?: string;
    padding?: string;
    withHeight(callback: (height: number) => Record<string, unknown>): Record<string, unknown>;
    entropy?: string;
    permit?: Record<string, unknown>;
}
export interface ContractMessageResponse<T> {
    parse(): T;
    getRaw(): ExecuteResult | TxsResponse;
    isEmpty(): boolean;
}
export declare type ContractQueryRequest = Record<string, Record<string, any>>;
export interface ContractMessageRequest {
    handleMsg: Record<string, unknown>;
    memo?: string;
    transferAmount?: Coin;
    fees?: number;
}
export interface ContractDefinition {
    queries?: Record<string, (context: Context, ...args: any[]) => ContractQueryRequest>;
    messages?: Record<string, (context: Context, ...args: any[]) => ContractMessageRequest>;
}
export interface BaseContractProps {
    id?: string;
    at: string;
    codeHash?: string;
}
export interface BaseContract extends BaseContractProps {
}
export interface ContractSpecification extends BaseContractProps {
    definition: ContractDefinition;
}
export interface ContractInstantiationRequest {
    id: string;
    codeId: number;
    definition: ContractDefinition;
    label: string;
    initMsg: object;
}
export declare class ErrorHandler {
    test: (e: any) => boolean;
    handler: () => void;
    constructor(test: (e: any) => boolean, handler: () => void);
}
export declare type MessageEntry = {
    contractAddress: string;
    handleMsg: object;
    transferAmount?: Coin[] | undefined;
};
export declare type MessageGetter = (...args: any[]) => Promise<ContractMessageResponse<unknown>>;
export interface MultiMessageInfo {
    getMessage: (...args: unknown[]) => ContractMessageRequest;
    contract: BaseContract;
    args: unknown[];
}
