import { ContractDefinition, BaseContract, ContractMessageResponse } from '../types';
export declare const snip721Def: ContractDefinition;
export declare const snip721PermitDef: ContractDefinition;
export declare type Expiration = {
    at_height: number;
} | {
    at_time: number;
} | 'never';
export declare type AccessLevel = 'approve_token' | 'all' | 'revoke_token' | 'none';
export declare type Transfer = {
    recipient: string;
    token_ids: Array<string>;
    memo?: string;
};
export declare type ReceiverInfo = {
    recipient_code_hash: string;
    also_implements_batch_receive_nft?: boolean;
};
export declare type Send = {
    contract: string;
    receiver_info?: ReceiverInfo;
    token_ids: Array<string>;
    msg?: string;
    memo?: string;
};
export declare type Burn = {
    token_ids: Array<string>;
    memo?: string;
};
export declare type SerialNumber = {
    mint_run?: number;
    serial_number: number;
    quantity_minted_this_run?: number;
};
export declare type Approval = {
    spender: string;
    expires: Expiration;
};
export declare type Metadata = {
    token_uri?: string;
    extension?: Extension;
};
export declare type RoyaltyInfo = {
    decimal_places_in_rates: number;
    royalties: Array<{
        recipient: string;
        rate: number;
    }>;
};
export declare type Mint = {
    token_id?: string;
    owner?: string;
    public_metadata?: Metadata;
    private_metadata?: Metadata;
    serial_number?: SerialNumber;
    royalty_info?: RoyaltyInfo;
    memo?: string;
};
export declare type Extension = {
    image?: string;
    image_data?: string;
    external_uri?: string;
    description?: string;
    name?: string;
    attributes?: Trait[];
    background_color?: string;
    animation_url?: string;
    youtube_url?: string;
    media?: Media[];
    protected_attributes?: string[];
};
export declare type Media = {
    file_type?: string;
    extension?: string;
    authentication?: {
        key?: string;
        user?: string;
    };
    url?: string;
};
export declare type Trait = {
    display_type?: string;
    trait_type?: string;
    value?: string;
    max_value?: string;
};
export interface Snip721Contract extends BaseContract {
    getContractInfo(): Promise<{
        contract_info: {
            name: string;
            symbol: string;
        };
    }>;
    getNumTokens(sendViewer?: boolean): Promise<{
        num_tokens: {
            count: number;
        };
    }>;
    getOwnerOf(token_id: string, include_expired?: boolean, sendViewer?: boolean): Promise<{
        owner_of: {
            owner: string;
            approvals: Approval[];
        };
    }>;
    getNftInfo(token_id: string): Promise<{
        nft_info: {
            name: string;
            description: string;
            image: string;
        };
    }>;
    getAllNftInfo(token_id: string, include_expired?: boolean, sendViewer?: boolean): Promise<{
        all_nft_info: {
            access: {
                owner: string;
                approvals: Approval[];
            };
            info: {
                name: string;
                description: string;
                image: string;
            };
        };
    }>;
    getPrivateMetadata(token_id: string, sendViewer?: boolean): Promise<{
        private_metadata: Metadata;
    }>;
    getNftDossier(token_id: string, include_expired?: boolean, sendViewer?: boolean): Promise<{
        nft_dossier: {
            owner: string;
            public_metadata: Metadata;
            private_metadata: Metadata;
            display_private_metadata_error: string;
            royalty_info: {
                decimal_places_in_rates: number;
                royalties: {
                    recipient: string;
                    rate: number;
                }[];
            };
            mint_run_info: {
                collection_creator: string;
                token_creator: string;
                time_of_minting: number;
                mint_run: number;
                serial_number: number;
                quantity_minted_this_run: number;
            };
            owner_is_public: boolean;
            public_ownership_expiration: Expiration;
            private_metadata_is_public: boolean;
            private_metadata_is_public_expiration: Expiration;
            token_approvals: {
                address: string;
                view_owner_expiration: Expiration;
                view_private_metadata_expiration: Expiration;
                transfer_expiration: Expiration;
            }[];
            inventory_approvals: {
                address: string;
                view_owner_expiration: Expiration;
                view_private_metadata_expiration: Expiration;
                transfer_expiration: Expiration;
            }[];
        };
    }>;
    getTokenApprovals(token_id: string, include_expired?: boolean): Promise<{
        token_approvals: {
            token_id: string;
            viewing_key: string;
            include_expired: boolean;
        };
    }>;
    getApprovedForAll(include_expired?: boolean, sendViewer?: boolean): {
        approved_for_all: {
            operators: {
                spender: string;
                expires: string;
            }[];
        };
    };
    getInventoryApprovals(include_expired?: boolean): Promise<{
        inventory_approvals: {
            owner_is_public: boolean;
            public_ownership_expiration: string;
            private_metadata_is_public: boolean;
            private_metadata_is_public_expiration: string;
            inventory_approvals: {
                address: string;
                view_owner_expiration: string;
                view_private_metadata_expiration: string;
                transfer_expiration: string;
            }[];
        };
    }>;
    getTokens(owner: string, start_after?: string, limit?: number, sendViewer?: boolean): Promise<{
        token_list: {
            tokens: string[];
        };
    }>;
    getTransactionHistory(page?: number, page_size?: number): Promise<{
        transaction_history: {
            total: number;
            txs: {
                tx_id: number;
                block_height: number;
                block_time: number;
                token_id: string;
                action: {
                    transfer?: {
                        from: string;
                        sender: string;
                        recipient: string;
                    };
                    mint?: {
                        minter: string;
                        recipient: string;
                    };
                    burn?: {
                        owner: string;
                        burner: string;
                    };
                };
                memo: string;
            }[];
        };
    }>;
    getAllTokens(limit?: number, sendViewer?: boolean): Promise<{
        token_list: {
            tokens: Array<string>;
        };
    }>;
    getMinters(): Promise<{
        minters: {
            minters: Array<string>;
        };
    }>;
    getRoyaltyInfo(token_id?: string): Promise<{
        royalty_info: RoyaltyInfo;
    }>;
    getIsUnwrapped(token_id: string): Promise<{
        is_unwrapped: {
            token_is_unwrapped: boolean;
        };
    }>;
    getVerifyTransferApproval(token_ids: Array<string>): Promise<{
        verify_transfer_approval: {
            approved_for_all: boolean;
            first_unapproved_token: string;
        };
    }>;
    transfer(recipient: string, token_id: string, memo?: string): Promise<ContractMessageResponse<{
        transfer_nft: {
            status: string;
        };
    }>>;
    send(contract: string, token_id: string, msg?: string, memo?: string): Promise<ContractMessageResponse<{
        send_nft: {
            status: string;
        };
    }>>;
    approve(spender: string, token_id: string, expires: Expiration): Promise<ContractMessageResponse<{
        approve: {
            status: string;
        };
    }>>;
    approveAll(operator: string, expires: Expiration): Promise<ContractMessageResponse<{
        approve_all: {
            status: string;
        };
    }>>;
    revoke(spender: string, token_id: string): Promise<ContractMessageResponse<{
        revoke: {
            status: string;
        };
    }>>;
    revokeAll(operator: string): Promise<ContractMessageResponse<{
        revoke_all: {
            status: string;
        };
    }>>;
    setWhiteListedApproval(address: string, token_id?: string, view_owner?: AccessLevel, view_private_metadata?: AccessLevel, transfer?: AccessLevel, expires?: Expiration): Promise<ContractMessageResponse<{
        set_whitelisted_approval: {
            status: string;
        };
    }>>;
    registerReceive(code_hash: string, also_implements_batch_receive_nft?: boolean): Promise<ContractMessageResponse<{
        register_receive_nft: {
            status: string;
        };
    }>>;
    createViewingKey(): Promise<ContractMessageResponse<{
        viewing_key: {
            key: string;
        };
    }>>;
    setViewingKey(key: string): Promise<ContractMessageResponse<{
        viewing_key: {
            key: string;
        };
    }>>;
    mintNft(token_id?: string, owner?: string, public_metadata?: Metadata, private_metadata?: Metadata, serial_number?: SerialNumber, royalty_info?: RoyaltyInfo, memo?: string): Promise<ContractMessageResponse<{
        mint_nft: {
            token_id: string;
        };
    }>>;
    mintNftClones(quantity: number, mint_run_id?: string, owner?: string, public_metadata?: Metadata, private_metadata?: Metadata, royalty_info?: RoyaltyInfo, memo?: string): Promise<ContractMessageResponse<{
        mint_nft_clones: {
            first_minted: string;
            last_minted: string;
        };
    }>>;
    addMinters(minters: Array<string>): Promise<ContractMessageResponse<{
        add_minters: {
            status: string;
        };
    }>>;
    removeMinters(minters: Array<string>): Promise<ContractMessageResponse<{
        remove_minters: {
            status: string;
        };
    }>>;
    setMinters(minters: Array<string>): Promise<ContractMessageResponse<{
        set_minters: {
            status: string;
        };
    }>>;
    setMetadata(token_id: string, public_metadata?: Metadata, private_metadata?: Metadata): Promise<ContractMessageResponse<{
        set_metadata: {
            status: string;
        };
    }>>;
    setRoyaltyInfo(token_id?: string, royalty_info?: RoyaltyInfo): Promise<ContractMessageResponse<{
        set_royalty_info: {
            status: string;
        };
    }>>;
    batchMintNft(mints: Array<Mint>): Promise<ContractMessageResponse<{
        batch_mint_nft: {
            token_ids: Array<string>;
        };
    }>>;
    batchTransferNft(transfers: Array<Transfer>): Promise<ContractMessageResponse<{
        batch_transfer_nft: {
            status: string;
        };
    }>>;
    batchSendNft(sends: Array<Send>): Promise<ContractMessageResponse<{
        batch_send_nft: {
            status: string;
        };
    }>>;
    burnNft(token_id: string, memo?: string): Promise<ContractMessageResponse<{
        burn_nft: {
            status: string;
        };
    }>>;
    BurnNft(burns: Array<Burn>): Promise<ContractMessageResponse<{
        batch_burn_nft: {
            status: string;
        };
    }>>;
    setGlobalApproval(token_id: string, view_owner?: AccessLevel, view_private_metadata?: AccessLevel, expires?: Expiration): Promise<ContractMessageResponse<{
        set_global_approval: {
            status: string;
        };
    }>>;
    reveal(token_id: string): Promise<ContractMessageResponse<{
        reveal: {
            status: string;
        };
    }>>;
}
